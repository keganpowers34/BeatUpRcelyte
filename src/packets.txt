head
	#define CONCAT1(a, b) a##b
	#define CONCAT0(a, b) CONCAT1(a, b)
	#define SERIALIZE_CUSTOM(ctx, pkt, stype) \
		for(uint8_t *start = *pkt; start;) \
			if(*pkt != start) { \
				struct SerializeHeader serial; \
				serial.length = *pkt + 1 - start; \
				serial.type = stype; \
				*pkt = start, start = NULL; \
				pkt_writeSerializeHeader(ctx, pkt, serial); \
				/*uprintf("serialize " #stype "\n");*/ \
				goto CONCAT0(_body_, __LINE__); \
			} else CONCAT0(_body_, __LINE__):
	uint8_t pkt_readUint8(struct PacketContext ctx, const uint8_t **pkt);
	uint16_t pkt_readUint16(struct PacketContext ctx, const uint8_t **pkt);
	uint32_t pkt_readUint32(struct PacketContext ctx, const uint8_t **pkt);
	uint64_t pkt_readUint64(struct PacketContext ctx, const uint8_t **pkt);
	#define pkt_readInt8(ctx, pkt) (int8_t)pkt_readUint8(ctx, pkt)
	#define pkt_readInt16(ctx, pkt) (int16_t)pkt_readUint16(ctx, pkt)
	#define pkt_readInt32(ctx, pkt) (int32_t)pkt_readUint32(ctx, pkt)
	#define pkt_readInt64(ctx, pkt) (int64_t)pkt_readUint64(ctx, pkt)
	uint64_t pkt_readVarUint64(struct PacketContext ctx, const uint8_t **pkt);
	uint64_t pkt_readVarUint64(struct PacketContext ctx, const uint8_t **pkt);
	int64_t pkt_readVarInt64(struct PacketContext ctx, const uint8_t **pkt);
	uint32_t pkt_readVarUint32(struct PacketContext ctx, const uint8_t **pkt);
	int32_t pkt_readVarInt32(struct PacketContext ctx, const uint8_t **pkt);
	void pkt_readUint8Array(const uint8_t **pkt, uint8_t *out, uint32_t count);
	float pkt_readFloat32(struct PacketContext ctx, const uint8_t **pkt);
	double pkt_readFloat64(struct PacketContext ctx, const uint8_t **pkt);
	void pkt_writeUint8(struct PacketContext ctx, uint8_t **pkt, uint8_t v);
	void pkt_writeUint16(struct PacketContext ctx, uint8_t **pkt, uint16_t v);
	void pkt_writeUint32(struct PacketContext ctx, uint8_t **pkt, uint32_t v);
	void pkt_writeUint64(struct PacketContext ctx, uint8_t **pkt, uint64_t v);
	#define pkt_writeInt8(ctx, pkt, v) pkt_writeUint8(ctx, pkt, (int8_t)v)
	#define pkt_writeInt16(ctx, pkt, v) pkt_writeUint16(ctx, pkt, (int16_t)v)
	#define pkt_writeInt32(ctx, pkt, v) pkt_writeUint32(ctx, pkt, (int32_t)v)
	#define pkt_writeInt64(ctx, pkt, v) pkt_writeUint64(ctx, pkt, (int64_t)v)
	void pkt_writeVarUint64(struct PacketContext ctx, uint8_t **pkt, uint64_t v);
	void pkt_writeVarInt64(struct PacketContext ctx, uint8_t **pkt, int64_t v);
	void pkt_writeVarUint32(struct PacketContext ctx, uint8_t **pkt, uint32_t v);
	void pkt_writeVarInt32(struct PacketContext ctx, uint8_t **pkt, int32_t v);
	#define pkt_writeInt8Array(ctx, pkt, out, count) pkt_writeUint8Array(ctx, pkt, (uint8_t*)out, count)
	void pkt_writeUint8Array(struct PacketContext ctx, uint8_t **pkt, const uint8_t *in, uint32_t count);
	void pkt_writeFloat32(struct PacketContext ctx, uint8_t **pkt, float v);
	void pkt_writeFloat64(struct PacketContext ctx, uint8_t **pkt, double v);

code
	#include "scramble.h"
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <inttypes.h>
	uint8_t pkt_readUint8(struct PacketContext ctx, const uint8_t **pkt) {
		uint8_t v = (*pkt)[0];
		*pkt += sizeof(v);
		return v;
	}
	uint16_t pkt_readUint16(struct PacketContext ctx, const uint8_t **pkt) {
		uint16_t v = (*pkt)[0] | (*pkt)[1] << 8;
		*pkt += sizeof(v);
		return v;
	}
	uint32_t pkt_readUint32(struct PacketContext ctx, const uint8_t **pkt) {
		uint32_t v = (*pkt)[0] | (*pkt)[1] << 8 | (*pkt)[2] << 16 | (*pkt)[3] << 24;
		*pkt += sizeof(v);
		return v;
	}
	uint64_t pkt_readUint64(struct PacketContext ctx, const uint8_t **pkt) {
		uint64_t v = (uint64_t)(*pkt)[0] | (uint64_t)(*pkt)[1] << 8 | (uint64_t)(*pkt)[2] << 16 | (uint64_t)(*pkt)[3] << 24 | (uint64_t)(*pkt)[4] << 32 | (uint64_t)(*pkt)[5] << 40 | (uint64_t)(*pkt)[6] << 48 | (uint64_t)(*pkt)[7] << 56;
		*pkt += sizeof(v);
		return v;
	}
	/*uint64_t pkt_readVarUint64(struct PacketContext ctx, const uint8_t **pkt) {
		uint64_t byte, value = 0;
		uint32_t shift = 0;
		for(; (byte = (uint64_t)pkt_readUint8(ctx, pkt)) & 128; shift += 7)
			value |= (byte & 127) << shift;
		return value | byte << shift;
	}*/
	uint64_t pkt_readVarUint64(struct PacketContext ctx, const uint8_t **pkt) {
		uint64_t byte, value = 0;
		uint8_t shift = 0;
		do {
			if(shift >= 64) {
				uprintf("Buffer overflow in read of VarUint\n");
				*pkt = _trap;
				return 0;
			}
			byte = pkt_readUint8(ctx, pkt);
			value |= (byte & 127) << shift;
			shift += 7;
		} while(byte & 128);
		return value;
	}
	int64_t pkt_readVarInt64(struct PacketContext ctx, const uint8_t **pkt) {
		int64_t varULong = (int64_t)pkt_readVarUint64(ctx, pkt);
		if((varULong & 1L) != 1L)
			return varULong >> 1;
		return -(varULong >> 1) + 1L;
	}
	uint32_t pkt_readVarUint32(struct PacketContext ctx, const uint8_t **pkt) {
		return (uint32_t)pkt_readVarUint64(ctx, pkt);
	}
	int32_t pkt_readVarInt32(struct PacketContext ctx, const uint8_t **pkt) {
		return (int32_t)pkt_readVarInt64(ctx, pkt);
	}
	#define pkt_readInt8Array(pkt, out, count) pkt_readUint8Array(pkt, (uint8_t*)out, count)
	void pkt_readUint8Array(const uint8_t **pkt, uint8_t *out, uint32_t count) {
		memcpy(out, *pkt, count);
		*pkt += count;
	}
	float pkt_readFloat32(struct PacketContext ctx, const uint8_t **pkt) {
		float v = *(const float*)*pkt;
		*pkt += 4;
		return v;
	}
	double pkt_readFloat64(struct PacketContext ctx, const uint8_t **pkt) {
		double v = *(const double*)*pkt;
		*pkt += 8;
		return v;
	}
	void pkt_writeUint8(struct PacketContext ctx, uint8_t **pkt, uint8_t v) {
		(*pkt)[0] = v;
		*pkt += sizeof(v);
	}
	void pkt_writeUint16(struct PacketContext ctx, uint8_t **pkt, uint16_t v) {
		(*pkt)[0] = v & 255;
		(*pkt)[1] = v >> 8 & 255;
		*pkt += sizeof(v);
	}
	void pkt_writeUint32(struct PacketContext ctx, uint8_t **pkt, uint32_t v) {
		(*pkt)[0] = v & 255;
		(*pkt)[1] = v >> 8 & 255;
		(*pkt)[2] = v >> 16 & 255;
		(*pkt)[3] = v >> 24 & 255;
		*pkt += sizeof(v);
	}
	void pkt_writeUint64(struct PacketContext ctx, uint8_t **pkt, uint64_t v) {
		(*pkt)[0] = v & 255;
		(*pkt)[1] = v >> 8 & 255;
		(*pkt)[2] = v >> 16 & 255;
		(*pkt)[3] = v >> 24 & 255;
		(*pkt)[4] = v >> 32 & 255;
		(*pkt)[5] = v >> 40 & 255;
		(*pkt)[6] = v >> 48 & 255;
		(*pkt)[7] = v >> 56 & 255;
		*pkt += sizeof(v);
	}
	void pkt_writeVarUint64(struct PacketContext ctx, uint8_t **pkt, uint64_t v) {
		do {
			uint8_t byte = v & 127;
			v >>= 7;
			if(v)
				byte |= 128;
			pkt_writeUint8(ctx, pkt, byte);
		} while(v);
	}
	void pkt_writeVarInt64(struct PacketContext ctx, uint8_t **pkt, int64_t v) {
		if(v < 0)
			pkt_writeVarUint64(ctx, pkt, (-(v + 1L) << 1) + 1L);
		else
			pkt_writeVarUint64(ctx, pkt, v << 1);
	}
	void pkt_writeVarUint32(struct PacketContext ctx, uint8_t **pkt, uint32_t v) {
		pkt_writeVarUint64(ctx, pkt, v);
	}
	void pkt_writeVarInt32(struct PacketContext ctx, uint8_t **pkt, int32_t v) {
		pkt_writeVarInt64(ctx, pkt, v);
	}
	void pkt_writeUint8Array(struct PacketContext ctx, uint8_t **pkt, const uint8_t *in, uint32_t count) {
		memcpy(*pkt, in, count);
		*pkt += count;
	}
	void pkt_writeFloat32(struct PacketContext ctx, uint8_t **pkt, float v) {
		*(float*)*pkt = v;
		*pkt += 4;
	}
	void pkt_writeFloat64(struct PacketContext ctx, uint8_t **pkt, double v) {
		*(double*)*pkt = v;
		*pkt += 8;
	}
	#define pkt_logUint8(ctx, name, buf, it, v) pkt_logUint64(ctx, name, buf, it, (uint64_t)v)
	#define pkt_logUint16(ctx, name, buf, it, v) pkt_logUint64(ctx, name, buf, it, (uint64_t)v)
	#define pkt_logUint32(ctx, name, buf, it, v) pkt_logUint64(ctx, name, buf, it, (uint64_t)v)
	#define pkt_logInt32(ctx, name, buf, it, v) pkt_logInt64(ctx, name, buf, it, (int64_t)v)
	#define pkt_logVarUint64 pkt_logUint64
	#define pkt_logVarInt64 pkt_logInt64
	#define pkt_logVarUint32 pkt_logUint32
	#define pkt_logVarInt32 pkt_logInt32
	static void pkt_logUint64(struct PacketContext ctx, const char *name, char *buf, char *it, uint64_t v) {
		uprintf("%.*s%s=%" PRIu64 "\n", (uint32_t)(it - buf), buf, name, v);
	}
	static void pkt_logInt64(struct PacketContext ctx, const char *name, char *buf, char *it, int64_t v) {
		uprintf("%.*s%s=%" PRId64 "\n", (uint32_t)(it - buf), buf, name, v);
	}
	#define pkt_logInt8Array(ctx, name, buf, it, in, count) pkt_logUint8Array(ctx, name, buf, it, (const uint8_t*)in, count)
	static void pkt_logUint8Array(struct PacketContext ctx, const char *name, char *buf, char *it, const uint8_t *in, uint32_t count) {
		uprintf("%.*s%s=", (uint32_t)(it - buf), buf, name);
		for(uint32_t i = 0; i < count; ++i)
			uprintf("%02hhx", in[i]);
		uprintf("\n");
	}
	#define pkt_logFloat32 pkt_logFloat64
	static void pkt_logFloat64(struct PacketContext ctx, const char *name, char *buf, char *it, double v) {
		uprintf("%.*s%s=%f\n", (uint32_t)(it - buf), buf, name, v);
	}

u8 Platform
	z Test
	z OculusRift
	z OculusQuest
	z Steam
	z PS4
	z PS4Dev
	z PS4Cert
	z Oculus 1
d PacketEncryptionLayer
	b encrypted
	if(.encrypted == 1)
		u32 sequenceId
		u8[16] iv
d BaseMasterServerReliableRequest
	u32 requestId
d BaseMasterServerResponse
	u32 responseId
d BaseMasterServerReliableResponse
	u32 requestId
	u32 responseId
d BaseMasterServerAcknowledgeMessage
	BaseMasterServerResponse base
	b messageHandled
d ByteArrayNetSerializable
	vu32 length
	u8[8192,.length] data
enum
	struct String {
		uint32_t length;
		_Bool isNull;
		char data[60];
	};
	struct LongString {
		uint32_t length;
		_Bool isNull;
		char data[4096];
	};
	struct ExString {
		struct String base;
		uint8_t tier;
	};
head
	struct String pkt_readString(struct PacketContext ctx, const uint8_t **pkt);
	struct LongString pkt_readLongString(struct PacketContext ctx, const uint8_t **pkt);
	void pkt_writeString(struct PacketContext ctx, uint8_t **pkt, struct String in);
	void pkt_writeLongString(struct PacketContext ctx, uint8_t **pkt, struct LongString in);
	void pkt_writeExString(struct PacketContext ctx, uint8_t **pkt, struct ExString in);
code
	struct String pkt_readString(struct PacketContext ctx, const uint8_t **pkt) {
		struct String out;
		out.isNull = 0;
		if(ctx.netVersion >= 12) {
			out.length = pkt_readUint16(ctx, pkt);
			if(out.length)
				--out.length;
			else
				out.isNull = 1;
		} else {
			out.length = pkt_readUint32(ctx, pkt);
		}
		if(out.length > 60) {
			uprintf("Buffer overflow in read of String.data: %u > 60\n", (uint32_t)out.length), out.length = 0, *pkt = _trap;
		} else {
			pkt_readInt8Array(pkt, out.data, out.length);
		}
		return out;
	}
	struct LongString pkt_readLongString(struct PacketContext ctx, const uint8_t **pkt) {
		struct LongString out;
		out.isNull = 0;
		if(ctx.netVersion >= 12) {
			out.length = pkt_readUint16(ctx, pkt);
			if(out.length)
				--out.length;
			else
				out.isNull = 1;
		} else {
			out.length = pkt_readUint32(ctx, pkt);
		}
		if(out.length > 4096) {
			uprintf("Buffer overflow in read of LongString.data: %u > 4096\n", (uint32_t)out.length), out.length = 0, *pkt = _trap;
		} else {
			pkt_readInt8Array(pkt, out.data, out.length);
		}
		return out;
	}
	void pkt_writeString(struct PacketContext ctx, uint8_t **pkt, struct String in) {
		if(ctx.netVersion >= 12)
			pkt_writeUint16(ctx, pkt, in.length + !in.isNull);
		else
			pkt_writeUint32(ctx, pkt, in.length);
		pkt_writeInt8Array(ctx, pkt, in.data, in.length);
	}
	void pkt_writeLongString(struct PacketContext ctx, uint8_t **pkt, struct LongString in) {
		if(ctx.netVersion >= 12)
			pkt_writeUint16(ctx, pkt, in.length + !in.isNull);
		else
			pkt_writeUint32(ctx, pkt, in.length);
		pkt_writeInt8Array(ctx, pkt, in.data, in.length);
	}
	void pkt_writeExString(struct PacketContext ctx, uint8_t **pkt, struct ExString in) {
		if(ctx.beatUpVersion)
			in.base.data[in.base.length++] = in.tier + 16;
		pkt_writeString(ctx, pkt, in.base);
	}
	#ifdef PACKET_LOGGING_FUNCS
	static void pkt_logString(struct PacketContext ctx, const char *name, char *buf, char *it, struct String in) {
		uprintf("%.*s%s=\"%.*s\"\n", (uint32_t)(it - buf), buf, name, in.length, in.data);
	}
	static void pkt_logLongString(struct PacketContext ctx, const char *name, char *buf, char *it, struct LongString in) {
		uprintf("%.*s%s=\"%.*s\"\n", (uint32_t)(it - buf), buf, name, in.length, in.data);
	}
	static void pkt_logExString(struct PacketContext ctx, const char *name, char *buf, char *it, struct ExString in) {
		pkt_logString(ctx, name, buf, it, in.base);
	}
	#endif
r AuthenticationToken
	u8.Platform platform
	String userId
	String userName
	ByteArrayNetSerializable sessionToken
d BaseMasterServerMultipartMessage
	BaseMasterServerReliableRequest base
	u32 multipartMessageId
	vu32 offset
	vu32 length
	vu32 totalLength
	u8[384,.length] data
d BitMask128
	u64 d0
	u64 d1
d SongPackMask
	BitMask128 bloomFilter
u8 BeatmapDifficultyMask
	z Easy 1
	z Normal 2
	z Hard 4
	z Expert 8
	z ExpertPlus 16
	z All 31
u32 GameplayModifierMask
	z None 0
	z BatteryEnergy 1
	z NoFail 2
	z InstaFail 4
	z NoObstacles 8
	z NoBombs 16
	z FastNotes 32
	z StrictAngles 64
	z DisappearingArrows 128
	z FasterSong 256
	z SlowerSong 512
	z NoArrows 1024
	z GhostNotes 2048
	z SuperFastSong 4096
	z ProMode 8192
	z ZenMode 16384
	z SmallCubes 32768
	z All 65535
d BeatmapLevelSelectionMask
	u8.BeatmapDifficultyMask difficulties
	u32.GameplayModifierMask modifiers
	SongPackMask songPacks
u8 DiscoveryPolicy
	z Hidden
	z WithCode
	z Public
u8 InvitePolicy
	z OnlyConnectionOwnerCanInvite
	z AnyoneCanInvite
	z NobodyCanInvite
u8 GameplayServerMode
	z Countdown
	z Managed
	z QuickStartOneSong
u8 SongSelectionMode
	z Vote
	z Random
	z OwnerPicks
	z RandomPlayerPicks
u8 GameplayServerControlSettings
	z None 0
	z AllowModifierSelection 1
	z AllowSpectate 2
	z All 3
d GameplayServerConfiguration
	vi32 maxPlayerCount
	vi32.DiscoveryPolicy discoveryPolicy
	vi32.InvitePolicy invitePolicy
	vi32.GameplayServerMode gameplayServerMode
	vi32.SongSelectionMode songSelectionMode
	vi32.GameplayServerControlSettings gameplayServerControlSettings
code
	ServerCode StringToServerCode(const char *in, uint32_t len) {
		static const uint8_t readTable[128] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,27,28,29,30,31,32,33,34,35,36,1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
		ServerCode out = 0;
		if(len <= 5)
			for(uint32_t i = 0, fac = 1; i < len; ++i, fac *= 36)
				out += readTable[in[i] & 127] * fac;
		return scramble_decode(out);
	}
	char *ServerCodeToString(char *out, ServerCode in) {
		char *s = out;
		for(in = scramble_encode(in); in; in /= 36)
			*s++ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[--in % 36];
		*s = 0;
		return out;
	}
	static ServerCode pkt_readServerCode(struct PacketContext ctx, const uint8_t **pkt) {
		struct String str = pkt_readString(ctx, pkt);
		return StringToServerCode(str.data, str.length);
	}
	static void pkt_writeServerCode(struct PacketContext ctx, uint8_t **pkt, ServerCode in) {
		struct String str = {.length = 0, .isNull = 0};
		for(in = scramble_encode(in); in; in /= 36)
			str.data[str.length++] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[--in % 36];
		pkt_writeString(ctx, pkt, str);
	}
	#ifdef PACKET_LOGGING_FUNCS
	static void pkt_logServerCode(struct PacketContext ctx, const char *name, char *buf, char *it, ServerCode in) {
		uprintf("%.*s%s=%u (\"", (uint32_t)(it - buf), buf, name, in);
		for(; in; in /= 36)
			uprintf("%c", "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[--in % 36]);
		uprintf("\")\n");
	}
	#endif
u32 ServerCode
head
	ServerCode StringToServerCode(const char *in, uint32_t len);
	char *ServerCodeToString(char *out, ServerCode in);
n PublicServerInfo
	ServerCode.ServerCode code
	vi32 currentPlayerCount
s IPEndPoint
	String address
	u32 port
u8 AuthenticateUserResponse_Result
	z Success
	z Failed
	z UnknownError
u8 ConnectToServerResponse_Result
	z Success
	z InvalidSecret
	z InvalidCode
	z InvalidPassword
	z ServerAtCapacity
	z NoAvailableDedicatedServers
	z VersionMismatch
	z ConfigMismatch
	z UnknownError
u8 GetPublicServersResponse_Result
	z Success
	z UnknownError
r BaseConnectToServerRequest
	BaseMasterServerReliableRequest base
	String userId
	String userName
	u8[32] random
	ByteArrayNetSerializable publicKey
u8 DeliveryMethod
	z ReliableUnordered
	z Sequenced
	z ReliableOrdered
	z ReliableSequenced
u8 PacketProperty
	z Unreliable
	d Channeled
		u16 sequence
		u8.DeliveryMethod channelId
	d Ack
		u16 sequence
		u8.DeliveryMethod channelId
		if(.channelId % 2 == 0)
			u8[16,ctx.windowSize/8] data
			u8 _pad0
	d Ping
		u16 sequence
	d Pong
		u16 sequence
		u64 time
	r ConnectRequest
		u32 protocolId
		u64 connectTime
		if((ctx.netVersion = .protocolId) >= 12)
			i32 peerId
		u8 addrlen
		u8[38,.addrlen] address
		String secret
		String userId
		String userName
		b isConnectionOwner
	s ConnectAccept
		u64 connectTime
		u8 connectNum
		b reusedPeer
		if(ctx.netVersion >= 12)
			i32 peerId
		if(ctx.beatUpVersion)
			u32 windowSize
			u8 countdownDuration
			u8.e bits
				u1.b directDownloads
				u1.b skipResults
				u1.b perPlayerDifficulty
				u1.b perPlayerModifiers
	r Disconnect
		u8[8] _pad0
	z UnconnectedMessage
	r MtuCheck
		u32 newMtu0
		u8[1423,.newMtu0-9] pad
		u32 newMtu1
	s MtuOk
		u32 newMtu0
		u8[1423,.newMtu0-9] pad
		u32 newMtu1
	z Broadcast
	z Merged
	z ShutdownOk
	z PeerNotFound
	z InvalidProtocol
	z NatMessage
	z Empty
r ModConnectHeader
	vu32 length
	String name
r BeatUpConnectHeader
	u32 protocolId
	u32 windowSize
	u8 countdownDuration
	u8.e bits
		u1.b directDownloads
		u1.b skipResults
		u1.b perPlayerDifficulty
		u1.b perPlayerModifiers
d NetPacketHeader
	u8.e bits
		u5.PacketProperty property
		u2.u8 connectionNumber
		u1.b isFragmented
d FragmentedHeader
	u16 fragmentId
	u16 fragmentPart
	u16 fragmentsTotal
d PlayerStateHash
	BitMask128 bloomFilter
d Color32
	u8 r
	u8 g
	u8 b
	u8 a
d MultiplayerAvatarData
	String headTopId
	Color32 headTopPrimaryColor
	Color32 handsColor
	String clothesId
	Color32 clothesPrimaryColor
	Color32 clothesSecondaryColor
	Color32 clothesDetailColor
	Color32[2] _unused
	String eyesId
	String mouthId
	Color32 glassesColor
	Color32 facialHairColor
	Color32 headTopSecondaryColor
	String glassesId
	String facialHairId
	String handsId
u32 DisconnectedReason
	z Unknown
	z UserInitiated
	z Timeout
	z Kicked
	z ServerAtCapacity
	z ServerConnectionClosed
	z MasterServerUnreachable
	z ClientConnectionClosed
	z NetworkDisconnected
	z ServerTerminated
d RoutingHeader
	u8 remoteConnectionId
	u8.e bits
		u7.u8 connectionId
		u1.b encrypted
u8 InternalMessage Type
	s SyncTime
		f32 syncTime
	s PlayerConnected
		u8 remoteConnectionId
		String userId
		ExString userName
		b isConnectionOwner
	d PlayerIdentity
		PlayerStateHash playerState
		MultiplayerAvatarData playerAvatar
		ByteArrayNetSerializable random
		ByteArrayNetSerializable publicEncryptionKey
	s PlayerLatencyUpdate
		f32 latency
	s PlayerDisconnected
		vi32.DisconnectedReason disconnectedReason
	s PlayerSortOrderUpdate
		String userId
		vi32 sortIndex
	n Party
	z MultiplayerSession
	n KickPlayer
		vi32.DisconnectedReason disconnectedReason
	r PlayerStateUpdate
		PlayerStateHash playerState
	n PlayerAvatarUpdate
		MultiplayerAvatarData playerAvatar
	r PingMessage
		f32 pingTime
	d PongMessage
		f32 pingTime
d RemoteProcedureCall
	f32 syncTime
head
	struct RemoteProcedureCallFlags pkt_readRemoteProcedureCallFlags(struct PacketContext ctx, const uint8_t **pkt);
code
	struct RemoteProcedureCallFlags pkt_readRemoteProcedureCallFlags(struct PacketContext ctx, const uint8_t **pkt) {
		struct RemoteProcedureCallFlags out;
		uint8_t bits = 255;
		if(ctx.protocolVersion > 6)
			bits = pkt_readUint8(ctx, pkt);
		out.hasValue0 = (bits >> 0) & 1;
		out.hasValue1 = (bits >> 1) & 1;
		out.hasValue2 = (bits >> 2) & 1;
		out.hasValue3 = (bits >> 3) & 1;
		return out;
	}
s RemoteProcedureCallFlags
	if(ctx.protocolVersion > 6)
		u8.e bits
			u1.b hasValue0
			u1.b hasValue1
			u1.b hasValue2
			u1.b hasValue3
s PlayersMissingEntitlementsNetSerializable
	i32 count
	String[128,.count] playersWithoutEntitlements
u8 EntitlementsStatus
	z Unknown
	z NotOwned
	z NotDownloaded
	z Ok
u32 BeatmapDifficulty
	z Easy
	z Normal
	z Hard
	z Expert
	z ExpertPlus
d BeatmapIdentifierNetSerializable
	LongString levelID
	String beatmapCharacteristicSerializedName
	vu32.BeatmapDifficulty difficulty
u8 EnabledObstacleType
	z All
	z FullHeightOnly
	z NoObstacles
u8 EnergyType
	z Bar
	z Battery
u8 SongSpeed
	z Normal
	z Faster
	z Slower
	z SuperFast
d GameplayModifiers
	i32.e bits
		u4.EnergyType energyType
		u1
		u1.b demoNoFail
		u1.b instaFail
		u1.b failOnSaberClash
		u4.EnabledObstacleType enabledObstacleType
		u1.b demoNoObstacles
		u1.b noBombs
		u1.b fastNotes
		u1.b strictAngles
		u1.b disappearingArrows
		u1.b ghostNotes
		u4.SongSpeed songSpeed
		u1.b noArrows
		u1.b noFailOn0Energy
		u1.b proMode
		u1.b zenMode
		u1.b smallCubes
s PlayerLobbyPermissionConfigurationNetSerializable
	String userId
	u8.e bits
		u1.b isServerOwner
		u1.b hasRecommendBeatmapsPermission
		u1.b hasRecommendGameplayModifiersPermission
		u1.b hasKickVotePermission
		u1.b hasInvitePermission
s PlayersLobbyPermissionConfigurationNetSerializable
	i32 count
	PlayerLobbyPermissionConfigurationNetSerializable[128,.count] playersPermission
r SyncStateId
	u8.e bits
		u7.u8 id
		u1.b same
r Vector3Serializable
	vi32 x
	vi32 y
	vi32 z
r QuaternionSerializable
	vi32 a
	vi32 b
	vi32 c
r PoseSerializable
	Vector3Serializable position
	QuaternionSerializable rotation
u8 CannotStartGameReason
	z None 1
	z AllPlayersSpectating
	z NoSongSelected
	z AllPlayersNotInLobby
	z DoNotOwnSong
u8 MultiplayerGameState
	z None
	z Lobby
	z Game
d ColorNoAlphaSerializable
	f32 r
	f32 g
	f32 b
d ColorSchemeNetSerializable
	ColorNoAlphaSerializable saberAColor
	ColorNoAlphaSerializable saberBColor
	ColorNoAlphaSerializable obstaclesColor
	ColorNoAlphaSerializable environmentColor0
	ColorNoAlphaSerializable environmentColor1
	ColorNoAlphaSerializable environmentColor0Boost
	ColorNoAlphaSerializable environmentColor1Boost
d PlayerSpecificSettingsNetSerializable
	String userId
	String userName
	b leftHanded
	b automaticPlayerHeight
	f32 playerHeight
	f32 headPosToPlayerHeightOffset
	ColorSchemeNetSerializable colorScheme
s PlayerSpecificSettingsAtStartNetSerializable
	i32 count
	PlayerSpecificSettingsNetSerializable[128,.count] activePlayerSpecificSettingsAtGameStart
i32 GameplayType
	z Normal
	z Bomb
	z BurstSliderHead
	z BurstSliderElement
	z BurstSliderElementFill
i32 ScoringType
	z Ignore -1
	z NoScore
	z Normal
	z SliderHead
	z SliderTail
	z BurstSliderHead
	z BurstSliderElement
i32 ColorType
	z ColorA 0
	z ColorB 1
	z None -1
u8 NoteLineLayer
	Base
	Upper
	Top
r NoteCutInfoNetSerializable
	u8.e bits
		u1.b cutWasOk
	f32 saberSpeed
	Vector3Serializable saberDir
	Vector3Serializable cutPoint
	Vector3Serializable cutNormal
	Vector3Serializable notePosition
	Vector3Serializable noteScale
	QuaternionSerializable noteRotation
	if(ctx.protocolVersion >= 8)
		vi32.GameplayType gameplayType
	vi32.ColorType colorType
	vi32.NoteLineLayer lineLayer
	vi32 noteLineIndex
	f32 noteTime
	f32 timeToNextColorNote
	Vector3Serializable moveVec
r NoteMissInfoNetSerializable
	vi32.ColorType colorType
	vi32.NoteLineLayer lineLayer
	vi32 noteLineIndex
	f32 noteTime
u8 MultiplayerLevelEndState
	z Cleared
	z Failed
	z GivenUp
	z WasInactive
	z StartupFailed
	z HostEndedLevel
	z ConnectedAfterLevelEnded
	z Quit
u8 MultiplayerPlayerLevelEndState
	z SongFinished
	z NotFinished
	z NotStarted
u8 MultiplayerPlayerLevelEndReason
	z Cleared
	z Failed
	z GivenUp
	z Quit
	z HostEndedLevel
	z WasInactive
	z StartupFailed
	z ConnectedAfterLevelEnded
u8 Rank
	z E
	z D
	z C
	z B
	z A
	z S
	z SS
	z SSS
u8 LevelEndStateType
	z None
	z Cleared
	z Failed
u8 LevelEndAction
	z None
	z Quit
	z Restart
r LevelCompletionResults
	GameplayModifiers gameplayModifiers
	vi32 modifiedScore
	vi32 multipliedScore
	vi32.Rank rank
	b fullCombo
	f32 leftSaberMovementDistance
	f32 rightSaberMovementDistance
	f32 leftHandMovementDistance
	f32 rightHandMovementDistance
	if(ctx.protocolVersion < 8)
		f32 songDuration
	vi32.LevelEndStateType levelEndStateType
	vi32.LevelEndAction levelEndAction
	f32 energy
	vi32 goodCutsCount
	vi32 badCutsCount
	vi32 missedCount
	vi32 notGoodCount
	vi32 okCount
	if(ctx.protocolVersion < 8)
		vi32 averageCutScore
	vi32 maxCutScore
	if(ctx.protocolVersion >= 8)
		vi32 totalCutScore
		vi32 goodCutsCountForNotesWithFullScoreScoringType
		i32 averageCenterDistanceCutScoreForNotesWithFullScoreScoringType
		i32 averageCutScoreForNotesWithFullScoreScoringType
	if(ctx.protocolVersion < 8)
		f32 averageCutDistanceRawScore
	vi32 maxCombo
	if(ctx.protocolVersion < 8)
		f32 minDirDeviation
		f32 maxDirDeviation
		f32 averageDirDeviation
		f32 minTimeDeviation
		f32 maxTimeDeviation
		f32 averageTimeDeviation
	f32 endSongTime
r MultiplayerLevelCompletionResults
	if(ctx.protocolVersion < 7)
		vi32.MultiplayerLevelEndState levelEndState
	if(ctx.protocolVersion >= 7)
		vi32.MultiplayerPlayerLevelEndState playerLevelEndState
		vi32.MultiplayerPlayerLevelEndReason playerLevelEndReason
	if((ctx.protocolVersion < 7 && .levelEndState < MultiplayerLevelEndState_GivenUp) || (ctx.protocolVersion >= 7 && .playerLevelEndState != MultiplayerPlayerLevelEndState_NotStarted))
		LevelCompletionResults levelCompletionResults
r NodePoseSyncState1
	PoseSerializable head
	PoseSerializable leftController
	PoseSerializable rightController
r StandardScoreSyncState
	vi32 modifiedScore
	vi32 rawScore
	vi32 immediateMaxPossibleRawScore
	vi32 combo
	vi32 multiplier
u8 NoteCutDirection
	z Up
	z Down
	z Left
	z Right
	z UpLeft
	z UpRight
	z DownLeft
	z DownRight
	z Any
	z None
r NoteSpawnInfoNetSerializable
	f32 time
	vi32 lineIndex
	vi32.NoteLineLayer noteLineLayer
	vi32.NoteLineLayer beforeJumpNoteLineLayer
	if(ctx.protocolVersion >= 8)
		vi32.GameplayType gameplayType
		vi32.ScoringType scoringType
	vi32.ColorType colorType
	vi32.NoteCutDirection cutDirection
	f32 timeToNextColorNote
	f32 timeToPrevColorNote
	vi32 flipLineIndex
	vi32 flipYSide
	Vector3Serializable moveStartPos
	Vector3Serializable moveEndPos
	Vector3Serializable jumpEndPos
	f32 jumpGravity
	f32 moveDuration
	f32 jumpDuration
	f32 rotation
	f32 cutDirectionAngleOffset
	if(ctx.protocolVersion >= 8)
		f32 cutSfxVolumeMultiplier
u8 ObstacleType
	z FullHeight
	z Top
r ObstacleSpawnInfoNetSerializable
	f32 time
	vi32 lineIndex
	if(ctx.protocolVersion >= 8)
		vi32.NoteLineLayer lineLayer
	if(ctx.protocolVersion < 8)
		vi32.ObstacleType obstacleType
	f32 duration
	vi32 width
	if(ctx.protocolVersion >= 8)
		vi32 height
	Vector3Serializable moveStartPos
	Vector3Serializable moveEndPos
	Vector3Serializable jumpEndPos
	f32 obstacleHeight
	f32 moveDuration
	f32 jumpDuration
	f32 noteLinesDistance
	f32 rotation
u8 SliderType
	z Normal
	z Burst
u8 SliderMidAnchorMode
	z Straight
	z Clockwise
	z CounterClockwise
r SliderSpawnInfoNetSerializable
	vi32.ColorType colorType
	vi32.SliderType sliderType
	b hasHeadNote
	f32 headTime
	vi32 headLineIndex
	vi32.NoteLineLayer headLineLayer
	vi32.NoteLineLayer headBeforeJumpLineLayer
	f32 headControlPointLengthMultiplier
	vi32.NoteCutDirection headCutDirection
	f32 headCutDirectionAngleOffset
	b hasTailNote
	f32 tailTime
	vi32 tailLineIndex
	vi32.NoteLineLayer tailLineLayer
	vi32.NoteLineLayer tailBeforeJumpLineLayer
	f32 tailControlPointLengthMultiplier
	vi32.NoteCutDirection tailCutDirection
	f32 tailCutDirectionAngleOffset
	vi32.SliderMidAnchorMode midAnchorMode
	vi32 sliceCount
	f32 squishAmount
	Vector3Serializable headMoveStartPos
	Vector3Serializable headJumpStartPos
	Vector3Serializable headJumpEndPos
	f32 headJumpGravity
	Vector3Serializable tailMoveStartPos
	Vector3Serializable tailJumpStartPos
	Vector3Serializable tailJumpEndPos
	f32 tailJumpGravity
	f32 moveDuration
	f32 jumpDuration
	f32 rotation
r PreviewDifficultyBeatmapSet
	String beatmapCharacteristicSerializedName
	u8 count
	vu32.BeatmapDifficulty[5,.count] difficulties
r NetworkPreviewBeatmapLevel
	LongString levelId
	LongString songName
	LongString songSubName
	LongString songAuthorName
	LongString levelAuthorName
	f32 beatsPerMinute
	f32 songTimeOffset
	f32 shuffle
	f32 shufflePeriod
	f32 previewStartTime
	f32 previewDuration
	f32 songDuration
	u8 count
	PreviewDifficultyBeatmapSet[8,.count] previewDifficultyBeatmapSets
	ByteArrayNetSerializable cover
d ShareInfo
	LongString levelId
	u8[32] levelHash
	vu64 fileSize
u8 LoadState
	None
	Failed
	Exporting
	Downloading
	Loading
	Done
u8 BeatUpMessage Type
	r RecommendPreview
		NetworkPreviewBeatmapLevel preview
		vu32 requirements_len
		String[16,.requirements_len] requirements
		vu32 suggestions_len
		String[16,.suggestions_len] suggestions
	r SetCanShareBeatmap
		ShareInfo base
		b canShare
	s DirectDownloadInfo
		ShareInfo base
		u8 count
		String[128,.count] sourcePlayers
	r LevelFragmentRequest
		vu64 offset
		u16 maxSize
	d LevelFragment
		vu64 offset
		u16 size
		u8[1500,.size] data
	r LoadProgress
		u32 sequence
		u8.LoadState state
		u16 progress
d BeatUpMessageHeader
	u8.BeatUpMessageType type
u8 MultiplayerSessionMessage Type
	u8 MenuRpc Type
		s SetPlayersMissingEntitlementsToLevel
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				PlayersMissingEntitlementsNetSerializable playersMissingEntitlements
		s GetIsEntitledToLevel
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				LongString levelId
		r SetIsEntitledToLevel
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				LongString levelId
			if(.flags.hasValue1)
				vi32.EntitlementsStatus entitlementStatus
		n InvalidateLevelEntitlementStatuses
			RemoteProcedureCall base
		n SelectLevelPack
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				String levelPackId
		s SetSelectedBeatmap
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				BeatmapIdentifierNetSerializable identifier
		r GetSelectedBeatmap
			RemoteProcedureCall base
		d RecommendBeatmap
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				BeatmapIdentifierNetSerializable identifier
		r ClearRecommendedBeatmap
			RemoteProcedureCall base
		d GetRecommendedBeatmap
			RemoteProcedureCall base
		s SetSelectedGameplayModifiers
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				GameplayModifiers gameplayModifiers
		r GetSelectedGameplayModifiers
			RemoteProcedureCall base
		d RecommendGameplayModifiers
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				GameplayModifiers gameplayModifiers
		r ClearRecommendedGameplayModifiers
			RemoteProcedureCall base
		d GetRecommendedGameplayModifiers
			RemoteProcedureCall base
		n LevelLoadError
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				LongString levelId
		n LevelLoadSuccess
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				LongString levelId
		s StartLevel
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				BeatmapIdentifierNetSerializable beatmapId
			if(.flags.hasValue1)
				GameplayModifiers gameplayModifiers
			if(.flags.hasValue2)
				f32 startTime
		r GetStartedLevel
			RemoteProcedureCall base
		s CancelLevelStart
			RemoteProcedureCall base
		r GetMultiplayerGameState
			RemoteProcedureCall base
		s SetMultiplayerGameState
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				vi32.MultiplayerGameState lobbyState
		d GetIsReady
			RemoteProcedureCall base
		d SetIsReady
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				b isReady
		s SetStartGameTime
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				f32 newTime
		n CancelStartGameTime
			RemoteProcedureCall base
		d GetIsInLobby
			RemoteProcedureCall base
		d SetIsInLobby
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				b isBack
		r GetCountdownEndTime
			RemoteProcedureCall base
		s SetCountdownEndTime
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				f32 newTime
		s CancelCountdown
			RemoteProcedureCall base
		s GetOwnedSongPacks
			RemoteProcedureCall base
		r SetOwnedSongPacks
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				SongPackMask songPackMask
		n RequestKickPlayer
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				String kickedPlayerId
		r GetPermissionConfiguration
			RemoteProcedureCall base
		s SetPermissionConfiguration
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				PlayersLobbyPermissionConfigurationNetSerializable playersPermissionConfiguration
		r GetIsStartButtonEnabled
			RemoteProcedureCall base
		s SetIsStartButtonEnabled
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				vi32.CannotStartGameReason reason
	u8 GameplayRpc Type
		s SetGameplaySceneSyncFinish
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				PlayerSpecificSettingsAtStartNetSerializable playersAtGameStart
			if(.flags.hasValue1)
				String sessionGameId
		r SetGameplaySceneReady
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				PlayerSpecificSettingsNetSerializable playerSpecificSettingsNetSerializable
		s GetGameplaySceneReady
			RemoteProcedureCall base
		n SetActivePlayerFailedToConnect
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				String failedUserId
			if(.flags.hasValue1)
				PlayerSpecificSettingsAtStartNetSerializable playersAtGameStartNetSerializable
			if(.flags.hasValue2)
				String sessionGameId
		r SetGameplaySongReady
			RemoteProcedureCall base
		s GetGameplaySongReady
			RemoteProcedureCall base
		s SetSongStartTime
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				f32 startTime
		r NoteCut
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				f32 songTime
			if(.flags.hasValue1)
				NoteCutInfoNetSerializable noteCutInfo
		r NoteMissed
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				f32 songTime
			if(.flags.hasValue1)
				NoteMissInfoNetSerializable noteMissInfo
		r LevelFinished
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				MultiplayerLevelCompletionResults results
		s ReturnToMenu
			RemoteProcedureCall base
		r RequestReturnToMenu
			RemoteProcedureCall base
		r NoteSpawned
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				f32 songTime
			if(.flags.hasValue1)
				NoteSpawnInfoNetSerializable noteSpawnInfo
		r ObstacleSpawned
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				f32 songTime
			if(.flags.hasValue1)
				ObstacleSpawnInfoNetSerializable obstacleSpawnInfo
		r SliderSpawned
			RemoteProcedureCall base
			RemoteProcedureCallFlags flags
			if(.flags.hasValue0)
				f32 songTime
			if(.flags.hasValue1)
				SliderSpawnInfoNetSerializable sliderSpawnInfo
	r NodePoseSyncState
		SyncStateId id
		f32 time
		NodePoseSyncState1 state
	r ScoreSyncState
		SyncStateId id
		f32 time
		StandardScoreSyncState state
	r NodePoseSyncStateDelta
		SyncStateId baseId
		vi32 timeOffsetMs
		if(.baseId.same == 0)
			NodePoseSyncState1 delta
	r ScoreSyncStateDelta
		SyncStateId baseId
		vi32 timeOffsetMs
		if(.baseId.same == 0)
			StandardScoreSyncState delta
	r MpCore 100
		String type
	z BeatUpMessage 101
d MultiplayerSessionMessageHeader
	u8.MultiplayerSessionMessageType type
d MenuRpcHeader
	u8.MenuRpcType type
d GameplayRpcHeader
	u8.GameplayRpcType type
r MpBeatmapPacket
	String levelHash
	LongString songName
	LongString songSubName
	LongString songAuthorName
	LongString levelAuthorName
	f32 beatsPerMinute
	f32 songDuration
	String characteristic
	u32.BeatmapDifficulty difficulty
i32 MpPlatform
	z Unknown
	z Steam
	z OculusPC
	z OculusQuest
	z PS4
r MpPlayerData
	String platformId
	i32.MpPlatform platform
r CustomAvatarPacket
	String hash
	f32 scale
	f32 floor
u8 UserMessage Type
	r AuthenticateUserRequest
		BaseMasterServerReliableResponse base
		AuthenticationToken authenticationToken
	s AuthenticateUserResponse
		BaseMasterServerReliableResponse base
		u8.AuthenticateUserResponse_Result result
	s ConnectToServerResponse 8
		BaseMasterServerReliableResponse base
		u8.ConnectToServerResponse_Result result
		if(.result == GetPublicServersResponse_Result_Success)
			String userId
			String userName
			String secret
			BeatmapLevelSelectionMask selectionMask
			u8 flags
			IPEndPoint remoteEndPoint
			u8[32] random
			ByteArrayNetSerializable publicKey
			ServerCode.ServerCode code
			GameplayServerConfiguration configuration
			String managerId
	r ConnectToServerRequest
		BaseConnectToServerRequest base
		BeatmapLevelSelectionMask selectionMask
		String secret
		ServerCode.ServerCode code
		GameplayServerConfiguration configuration
	n UserMessageReceivedAcknowledge 13
		BaseMasterServerAcknowledgeMessage base
	n UserMultipartMessage
		BaseMasterServerMultipartMessage base
	n SessionKeepaliveMessage
	n GetPublicServersRequest
		BaseMasterServerReliableRequest base
		String userId
		String userName
		vi32 offset
		vi32 count
		BeatmapLevelSelectionMask selectionMask
		GameplayServerConfiguration configuration
	n GetPublicServersResponse
		BaseMasterServerReliableResponse base
		u8.GetPublicServersResponse_Result result
		if(.result == GetPublicServersResponse_Result_Success)
			vu32 publicServerCount
			PublicServerInfo[8192,.publicServerCount] publicServers
u8 DedicatedServerMessage Type
	z DedicatedServerMessageReceivedAcknowledge 13
	z DedicatedServerMultipartMessage 14
u8 GameLiftMessage Type
	z AuthenticateUserRequest
	z AuthenticateUserResponse
	z GameLiftMessageReceivedAcknowledge
	z GameLiftMultipartMessage
u8 HandshakeMessage Type
	r ClientHelloRequest
		BaseMasterServerReliableRequest base
		u8[32] random
	s HelloVerifyRequest
		BaseMasterServerReliableResponse base
		u8[32] cookie
	r ClientHelloWithCookieRequest
		BaseMasterServerReliableRequest base
		u32 certificateResponseId
		u8[32] random
		u8[32] cookie
	s ServerHelloRequest
		BaseMasterServerReliableResponse base
		u8[32] random
		ByteArrayNetSerializable publicKey
		ByteArrayNetSerializable signature
	s ServerCertificateRequest
		BaseMasterServerReliableResponse base
		vu32 certificateCount
		ByteArrayNetSerializable[10,.certificateCount] certificateList
	r ClientKeyExchangeRequest 6
		BaseMasterServerReliableResponse base
		ByteArrayNetSerializable clientPublicKey
	s ChangeCipherSpecRequest
		BaseMasterServerReliableResponse base
	n HandshakeMessageReceivedAcknowledge
		BaseMasterServerAcknowledgeMessage base
	n HandshakeMultipartMessage
		BaseMasterServerMultipartMessage base

enum
	#ifdef reflect
	static const char *const reflect_MessageType = "{MessageType_UserMessage=1,MessageType_DedicatedServerMessage=2,MessageType_GameLiftMessage=3,MessageType_HandshakeMessage=3192347326,}";
	#endif
	typedef uint32_t MessageType;
	#define MessageType_UserMessage 1
	#define MessageType_DedicatedServerMessage 2
	#define MessageType_GameLiftMessage 3
	#define MessageType_HandshakeMessage 3192347326u
code
	void pkt_logMessageType(struct PacketContext ctx, const char *name, char *buf, char *it, MessageType in) {
		uprintf("%.*s%s=%u (%s)\n", (uint32_t)(it - buf), buf, name, in, reflect(MessageType, in));
	}
d MessageHeader
	u32.MessageType type
	vu32 protocolVersion
d SerializeHeader
	vu32 length
	u8 type
