head
	#define CONCAT1(a, b) a##b
	#define CONCAT0(a, b) CONCAT1(a, b)
	#define SERIALIZE_CUSTOM(pkt, stype) \
		for(uint8_t *start = *pkt; start;) \
			if(*pkt != start) { \
				struct SerializeHeader serial; \
				serial.length = *pkt + 1 - start; \
				serial.type = stype; \
				*pkt = start, start = NULL; \
				pkt_writeSerializeHeader(pkt, serial); \
				fprintf(stderr, "serialize " #stype "\n"); \
				goto CONCAT0(_body_, __LINE__); \
			} else CONCAT0(_body_, __LINE__):
	uint8_t pkt_readUint8(const uint8_t **pkt);
	uint16_t pkt_readUint16(const uint8_t **pkt);
	uint32_t pkt_readUint32(const uint8_t **pkt);
	uint64_t pkt_readUint64(const uint8_t **pkt);
	#define pkt_readInt8(pkt) (int8_t)pkt_readUint8(pkt)
	#define pkt_readInt16(pkt) (int16_t)pkt_readUint16(pkt)
	#define pkt_readInt32(pkt) (int32_t)pkt_readUint32(pkt)
	#define pkt_readInt64(pkt) (int64_t)pkt_readUint64(pkt)
	uint64_t pkt_readVarUint64(const uint8_t **pkt);
	uint64_t pkt_readVarUint64(const uint8_t **pkt);
	int64_t pkt_readVarInt64(const uint8_t **pkt);
	uint32_t pkt_readVarUint32(const uint8_t **pkt);
	int32_t pkt_readVarInt32(const uint8_t **pkt);
	void pkt_readUint8Array(const uint8_t **pkt, uint8_t *out, uint32_t count);
	float pkt_readFloat32(const uint8_t **pkt);
	double pkt_readFloat64(const uint8_t **pkt);
	void pkt_writeUint8(uint8_t **pkt, uint8_t v);
	void pkt_writeUint16(uint8_t **pkt, uint16_t v);
	void pkt_writeUint32(uint8_t **pkt, uint32_t v);
	void pkt_writeUint64(uint8_t **pkt, uint64_t v);
	#define pkt_writeInt8(pkt, v) pkt_writeUint8(pkt, (int8_t)v)
	#define pkt_writeInt16(pkt, v) pkt_writeUint16(pkt, (int16_t)v)
	#define pkt_writeInt32(pkt, v) pkt_writeUint32(pkt, (int32_t)v)
	#define pkt_writeInt64(pkt, v) pkt_writeUint64(pkt, (int64_t)v)
	void pkt_writeVarUint64(uint8_t **pkt, uint64_t v);
	void pkt_writeVarInt64(uint8_t **pkt, int64_t v);
	void pkt_writeVarUint32(uint8_t **pkt, uint32_t v);
	void pkt_writeVarInt32(uint8_t **pkt, int32_t v);
	#define pkt_writeInt8Array(pkt, out, count) pkt_writeUint8Array(pkt, (uint8_t*)out, count)
	void pkt_writeUint8Array(uint8_t **pkt, const uint8_t *in, uint32_t count);
	void pkt_writeFloat32(uint8_t **pkt, float v);
	void pkt_writeFloat64(uint8_t **pkt, double v);

code
	#include "scramble.h"
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <inttypes.h>
	uint8_t pkt_readUint8(const uint8_t **pkt) {
		uint8_t v = (*pkt)[0];
		*pkt += sizeof(v);
		return v;
	}
	uint16_t pkt_readUint16(const uint8_t **pkt) {
		uint16_t v = (*pkt)[0] | (*pkt)[1] << 8;
		*pkt += sizeof(v);
		return v;
	}
	uint32_t pkt_readUint32(const uint8_t **pkt) {
		uint32_t v = (*pkt)[0] | (*pkt)[1] << 8 | (*pkt)[2] << 16 | (*pkt)[3] << 24;
		*pkt += sizeof(v);
		return v;
	}
	uint64_t pkt_readUint64(const uint8_t **pkt) {
		uint64_t v = (uint64_t)(*pkt)[0] | (uint64_t)(*pkt)[1] << 8 | (uint64_t)(*pkt)[2] << 16 | (uint64_t)(*pkt)[3] << 24 | (uint64_t)(*pkt)[4] << 32 | (uint64_t)(*pkt)[5] << 40 | (uint64_t)(*pkt)[6] << 48 | (uint64_t)(*pkt)[7] << 56;
		*pkt += sizeof(v);
		return v;
	}
	/*uint64_t pkt_readVarUint64(const uint8_t **pkt) {
		uint64_t byte, value = 0;
		uint32_t shift = 0;
		for(; (byte = (uint64_t)pkt_readUint8(pkt)) & 128; shift += 7)
			value |= (byte & 127) << shift;
		return value | byte << shift;
	}*/
	uint64_t pkt_readVarUint64(const uint8_t **pkt) {
		uint64_t byte, value = 0;
		uint8_t shift = 0;
		do {
			if(shift >= 64) {
				fprintf(stderr, "Buffer overflow in read of VarUint\n");
				*pkt = _trap;
				return 0;
			}
			byte = pkt_readUint8(pkt);
			value |= (byte & 127) << shift;
			shift += 7;
		} while(byte & 128);
		return value;
	}
	int64_t pkt_readVarInt64(const uint8_t **pkt) {
		int64_t varULong = (int64_t)pkt_readVarUint64(pkt);
		if((varULong & 1L) != 1L)
			return varULong >> 1;
		return -(varULong >> 1) + 1L;
	}
	uint32_t pkt_readVarUint32(const uint8_t **pkt) {
		return (uint32_t)pkt_readVarUint64(pkt);
	}
	int32_t pkt_readVarInt32(const uint8_t **pkt) {
		return (int32_t)pkt_readVarInt64(pkt);
	}
	#define pkt_readInt8Array(pkt, out, count) pkt_readUint8Array(pkt, (uint8_t*)out, count)
	void pkt_readUint8Array(const uint8_t **pkt, uint8_t *out, uint32_t count) {
		memcpy(out, *pkt, count);
		*pkt += count;
	}
	float pkt_readFloat32(const uint8_t **pkt) {
		float v = *(const float*)*pkt;
		*pkt += 4;
		return v;
	}
	double pkt_readFloat64(const uint8_t **pkt) {
		double v = *(const double*)*pkt;
		*pkt += 8;
		return v;
	}
	void pkt_writeUint8(uint8_t **pkt, uint8_t v) {
		(*pkt)[0] = v;
		*pkt += sizeof(v);
	}
	void pkt_writeUint16(uint8_t **pkt, uint16_t v) {
		(*pkt)[0] = v & 255;
		(*pkt)[1] = v >> 8 & 255;
		*pkt += sizeof(v);
	}
	void pkt_writeUint32(uint8_t **pkt, uint32_t v) {
		(*pkt)[0] = v & 255;
		(*pkt)[1] = v >> 8 & 255;
		(*pkt)[2] = v >> 16 & 255;
		(*pkt)[3] = v >> 24 & 255;
		*pkt += sizeof(v);
	}
	void pkt_writeUint64(uint8_t **pkt, uint64_t v) {
		(*pkt)[0] = v & 255;
		(*pkt)[1] = v >> 8 & 255;
		(*pkt)[2] = v >> 16 & 255;
		(*pkt)[3] = v >> 24 & 255;
		(*pkt)[4] = v >> 32 & 255;
		(*pkt)[5] = v >> 40 & 255;
		(*pkt)[6] = v >> 48 & 255;
		(*pkt)[7] = v >> 56 & 255;
		*pkt += sizeof(v);
	}
	void pkt_writeVarUint64(uint8_t **pkt, uint64_t v) {
		do {
			uint8_t byte = v & 127;
			v >>= 7;
			if(v)
				byte |= 128;
			pkt_writeUint8(pkt, byte);
		} while(v);
	}
	void pkt_writeVarInt64(uint8_t **pkt, int64_t v) {
		if(v < 0)
			pkt_writeVarUint64(pkt, (-(v + 1L) << 1) + 1L);
		else
			pkt_writeVarUint64(pkt, v << 1);
	}
	void pkt_writeVarUint32(uint8_t **pkt, uint32_t v) {
		pkt_writeVarUint64(pkt, v);
	}
	void pkt_writeVarInt32(uint8_t **pkt, int32_t v) {
		pkt_writeVarInt64(pkt, v);
	}
	void pkt_writeUint8Array(uint8_t **pkt, const uint8_t *in, uint32_t count) {
		memcpy(*pkt, in, count);
		*pkt += count;
	}
	void pkt_writeFloat32(uint8_t **pkt, float v) {
		*(float*)*pkt = v;
		*pkt += 4;
	}
	void pkt_writeFloat64(uint8_t **pkt, double v) {
		*(double*)*pkt = v;
		*pkt += 8;
	}
	#define pkt_logUint8(name, buf, it, v) pkt_logUint64(name, buf, it, (uint64_t)v)
	#define pkt_logUint16(name, buf, it, v) pkt_logUint64(name, buf, it, (uint64_t)v)
	#define pkt_logUint32(name, buf, it, v) pkt_logUint64(name, buf, it, (uint64_t)v)
	#define pkt_logInt32(name, buf, it, v) pkt_logInt64(name, buf, it, (int64_t)v)
	#define pkt_logVarUint64 pkt_logUint64
	#define pkt_logVarInt64 pkt_logInt64
	#define pkt_logVarUint32 pkt_logUint32
	#define pkt_logVarInt32 pkt_logInt32
	static void pkt_logUint64(const char *name, char *buf, char *it, uint64_t v) {
		fprintf(stderr, "%.*s%s=%" PRIu64 "\n", (uint32_t)(it - buf), buf, name, v);
	}
	static void pkt_logInt64(const char *name, char *buf, char *it, int64_t v) {
		fprintf(stderr, "%.*s%s=%" PRId64 "\n", (uint32_t)(it - buf), buf, name, v);
	}
	#define pkt_logInt8Array(name, buf, it, in, count) pkt_logUint8Array(name, buf, it, (const uint8_t*)in, count)
	static void pkt_logUint8Array(const char *name, char *buf, char *it, const uint8_t *in, uint32_t count) {
		fprintf(stderr, "%.*s%s=", (uint32_t)(it - buf), buf, name);
		for(uint32_t i = 0; i < count; ++i)
			fprintf(stderr, "%02hhx", in[i]);
		fprintf(stderr, "\n");
	}
	#define pkt_logFloat32 pkt_logFloat64
	static void pkt_logFloat64(const char *name, char *buf, char *it, double v) {
		fprintf(stderr, "%.*s%s=%f\n", (uint32_t)(it - buf), buf, name, v);
	}

u8 Platform
	z Test
	z OculusRift
	z OculusQuest
	z Steam
	z PS4
	z PS4Dev
	z PS4Cert
	z Oculus 1
d PacketEncryptionLayer
	b encrypted
	if(encrypted == 1)
		u32 sequenceId
		u8[16] iv
d BaseMasterServerReliableRequest
	u32 requestId
d BaseMasterServerResponse
	u32 responseId
d BaseMasterServerReliableResponse
	u32 requestId
	u32 responseId
d BaseMasterServerAcknowledgeMessage
	BaseMasterServerResponse base
	b messageHandled
d ByteArrayNetSerializable
	vu32 length
	u8[4096,length] data
code
	#ifdef PACKET_LOGGING_FUNCS
	static void pkt_logString(const char *name, char *buf, char *it, struct String in) {
		fprintf(stderr, "%.*s%s=\"%.*s\"\n", (uint32_t)(it - buf), buf, name, in.length, in.data);
	}
	#endif
d String
	u32 length
	c[60,length] data
r AuthenticationToken
	u8.Platform platform
	String userId
	String userName
	ByteArrayNetSerializable sessionToken
s BaseMasterServerMultipartMessage
	BaseMasterServerReliableRequest base
	u32 multipartMessageId
	vu32 offset
	vu32 length
	vu32 totalLength
	u8[384,length] data
d BitMask128
	u64 d0
	u64 d1
d SongPackMask
	BitMask128 bloomFilter
u8 BeatmapDifficultyMask
	z Easy 1
	z Normal 2
	z Hard 4
	z Expert 8
	z ExpertPlus 16
	z All 31
u32 GameplayModifierMask
	z None 0
	z BatteryEnergy 1
	z NoFail 2
	z InstaFail 4
	z NoObstacles 8
	z NoBombs 16
	z FastNotes 32
	z StrictAngles 64
	z DisappearingArrows 128
	z FasterSong 256
	z SlowerSong 512
	z NoArrows 1024
	z GhostNotes 2048
	z SuperFastSong 4096
	z ProMode 8192
	z ZenMode 16384
	z SmallCubes 32768
	z All 65535
d BeatmapLevelSelectionMask
	u8.BeatmapDifficultyMask difficulties
	u32.GameplayModifierMask modifiers
	SongPackMask songPacks
u8 DiscoveryPolicy
	z Hidden
	z WithCode
	z Public
u8 InvitePolicy
	z OnlyConnectionOwnerCanInvite
	z AnyoneCanInvite
	z NobodyCanInvite
u8 GameplayServerMode
	z Countdown
	z Managed
	z QuickStartOneSong
u8 SongSelectionMode
	z Vote
	z Random
	z OwnerPicks
	z RandomPlayerPicks
u8 GameplayServerControlSettings
	z None 0
	z AllowModifierSelection 1
	z AllowSpectate 2
	z All 3
d GameplayServerConfiguration
	vi32 maxPlayerCount
	vi32.DiscoveryPolicy discoveryPolicy
	vi32.InvitePolicy invitePolicy
	vi32.GameplayServerMode gameplayServerMode
	vi32.SongSelectionMode songSelectionMode
	vi32.GameplayServerControlSettings gameplayServerControlSettings
code
	ServerCode StringToServerCode(const char *in, uint32_t len) {
		static const uint8_t readTable[128] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,27,28,29,30,31,32,33,34,35,36,1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
		ServerCode out = 0;
		if(len <= 5)
			for(uint32_t i = 0, fac = 1; i < len; ++i, fac *= 36)
				out += readTable[in[i] & 127] * fac;
		return scramble_decode(out);
	}
	char *ServerCodeToString(char *out, ServerCode in) {
		char *s = out;
		for(in = scramble_encode(in); in; in /= 36)
			*s++ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[--in % 36];
		*s = 0;
		return out;
	}
	static ServerCode pkt_readServerCode(const uint8_t **pkt) {
		struct String str = pkt_readString(pkt);
		return StringToServerCode(str.data, str.length);
	}
	static void pkt_writeServerCode(uint8_t **pkt, ServerCode in) {
		struct String str = {.length = 0};
		for(in = scramble_encode(in); in; in /= 36)
			str.data[str.length++] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[--in % 36];
		pkt_writeString(pkt, str);
	}
	#ifdef PACKET_LOGGING_FUNCS
	static void pkt_logServerCode(const char *name, char *buf, char *it, ServerCode in) {
		fprintf(stderr, "%.*s%s=%u (\"", (uint32_t)(it - buf), buf, name, in);
		for(; in; in /= 36)
			fprintf(stderr, "%c", "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[--in % 36]);
		fprintf(stderr, "\")\n");
	}
	#endif
u32 ServerCode
head
	ServerCode StringToServerCode(const char *in, uint32_t len);
	char *ServerCodeToString(char *out, ServerCode in);
n PublicServerInfo
	ServerCode.ServerCode code
	vi32 currentPlayerCount
s IPEndPoint
	String address
	u32 port
u8 AuthenticateUserResponse_Result
	z Success
	z Failed
	z UnknownError
u8 ConnectToServerResponse_Result
	z Success
	z InvalidSecret
	z InvalidCode
	z InvalidPassword
	z ServerAtCapacity
	z NoAvailableDedicatedServers
	z VersionMismatch
	z ConfigMismatch
	z UnknownError
u8 GetPublicServersResponse_Result
	z Success
	z UnknownError
r BaseConnectToServerRequest
	BaseMasterServerReliableRequest base
	String userId
	String userName
	u8[32] random
	ByteArrayNetSerializable publicKey
u8 DeliveryMethod
	z ReliableUnordered
	z Sequenced
	z ReliableOrdered
	z ReliableSequenced
u8 PacketProperty
	z Unreliable
	d Channeled
		u16 sequence
		u8.DeliveryMethod channelId
	d Ack
		u16 sequence
		u8.DeliveryMethod channelId
		if(channelId % 2 == 0)
			u8[9] data
	r Ping
		u16 sequence
	s Pong
		u16 sequence
		u64 time
	r ConnectRequest
		u32 protocolId
		u64 connectId
		u8 addrlen
		u8[38,addrlen] address
		String secret
		String userId
		String userName
		b isConnectionOwner
	s ConnectAccept
		u64 connectId
		u8 connectNum
		b reusedPeer
	r Disconnect
		u8[8] _pad0
	z UnconnectedMessage
	r MtuCheck
		u32 newMtu0
		u8[1423,newMtu0-9] pad
		u32 newMtu1
	s MtuOk
		u32 newMtu0
		u8[1423,newMtu0-9] pad
		u32 newMtu1
	z Broadcast
	z Merged
	z ShutdownOk
	z PeerNotFound
	z InvalidProtocol
	z NatMessage
	z Empty
d NetPacketHeader
	u8.e bits
		u5.PacketProperty property
		u2.u8 connectionNumber
		u1.b isFragmented
r FragmentedHeader
	u16 fragmentId
	u16 fragmentPart
	u16 fragmentsTotal
d PlayerStateHash
	BitMask128 bloomFilter
d Color32
	u8 r
	u8 g
	u8 b
	u8 a
d MultiplayerAvatarData
	String headTopId
	Color32 headTopPrimaryColor
	Color32 handsColor
	String clothesId
	Color32 clothesPrimaryColor
	Color32 clothesSecondaryColor
	Color32 clothesDetailColor
	Color32[2] _unused
	String eyesId
	String mouthId
	Color32 glassesColor
	Color32 facialHairColor
	Color32 headTopSecondaryColor
	String glassesId
	String facialHairId
	String handsId
u32 DisconnectedReason
	z Unknown
	z UserInitiated
	z Timeout
	z Kicked
	z ServerAtCapacity
	z ServerConnectionClosed
	z MasterServerUnreachable
	z ClientConnectionClosed
	z NetworkDisconnected
	z ServerTerminated
d RoutingHeader
	u8 remoteConnectionId
	u8.e bits
		u7.u8 connectionId
		u1.b encrypted
u8 InternalMessage Type
	s SyncTime
		f32 syncTime
	s PlayerConnected
		u8 remoteConnectionId
		String userId
		String userName
		b isConnectionOwner
	d PlayerIdentity
		PlayerStateHash playerState
		MultiplayerAvatarData playerAvatar
		ByteArrayNetSerializable random
		ByteArrayNetSerializable publicEncryptionKey
	n PlayerLatencyUpdate
		f32 latency
	n PlayerDisconnected
		vi32.DisconnectedReason disconnectedReason
	s PlayerSortOrderUpdate
		String userId
		vi32 sortIndex
	n Party
	z MultiplayerSession
	n KickPlayer
		vi32.DisconnectedReason disconnectedReason
	r PlayerStateUpdate
		PlayerStateHash playerState
	n PlayerAvatarUpdate
		MultiplayerAvatarData playerAvatar
d RemoteProcedureCall
	f32 syncTime
s PlayersMissingEntitlementsNetSerializable
	i32 count
	String[128,count] playersWithoutEntitlements
u8 EntitlementsStatus
	z Unknown
	z NotOwned
	z NotDownloaded
	z Ok
u32 BeatmapDifficulty
	z Easy
	z Normal
	z Hard
	z Expert
	z ExpertPlus
r BeatmapIdentifierNetSerializable
	String levelID
	String beatmapCharacteristicSerializedName
	vu32.BeatmapDifficulty difficulty
u8 EnabledObstacleType
	z All
	z FullHeightOnly
	z NoObstacles
u8 EnergyType
	z Bar
	z Battery
u8 SongSpeed
	z Normal
	z Faster
	z Slower
	z SuperFast
d GameplayModifiers
	i32.e bits
		u4.EnergyType energyType
		u1
		u1.b demoNoFail
		u1.b instaFail
		u1.b failOnSaberClash
		u4.EnabledObstacleType enabledObstacleType
		u1.b demoNoObstacles
		u1.b noBombs
		u1.b fastNotes
		u1.b strictAngles
		u1.b disappearingArrows
		u1.b ghostNotes
		u4.SongSpeed songSpeed
		u1.b noArrows
		u1.b noFailOn0Energy
		u1.b proMode
		u1.b zenMode
		u1.b smallCubes
s PlayerLobbyPermissionConfigurationNetSerializable
	String userId
	u8.e bits
		u1.b isServerOwner
		u1.b hasRecommendBeatmapsPermission
		u1.b hasRecommendGameplayModifiersPermission
		u1.b hasKickVotePermission
		u1.b hasInvitePermission
s PlayersLobbyPermissionConfigurationNetSerializable
	i32 count
	PlayerLobbyPermissionConfigurationNetSerializable[128,count] playersPermission
r SyncStateId
	u8.e bits
		u7.u8 id
		u1.b same
r Vector3Serializable
	vi32 x
	vi32 y
	vi32 z
r QuaternionSerializable
	vi32 a
	vi32 b
	vi32 c
r PoseSerializable
	Vector3Serializable position
	QuaternionSerializable rotation
u8 CannotStartGameReason
	z None 1
	z AllPlayersSpectating
	z NoSongSelected
	z AllPlayersNotInLobby
	z DoNotOwnSong
u8 MultiplayerGameState
	z None
	z Lobby
	z Game
r NodePoseSyncState1
	PoseSerializable head
	PoseSerializable leftController
	PoseSerializable rightController
u8 MultiplayerSessionMessage Type
	u8 MenuRpc Type
		s SetPlayersMissingEntitlementsToLevel
			RemoteProcedureCall base
			PlayersMissingEntitlementsNetSerializable playersMissingEntitlements
		s GetIsEntitledToLevel
			RemoteProcedureCall base
			String levelId
		r SetIsEntitledToLevel
			RemoteProcedureCall base
			String levelId
			vi32.EntitlementsStatus entitlementStatus
		n InvalidateLevelEntitlementStatuses
			RemoteProcedureCall base
		n SelectLevelPack
			RemoteProcedureCall base
			String levelPackId
		n SetSelectedBeatmap
			RemoteProcedureCall base
			BeatmapIdentifierNetSerializable identifier
		n GetSelectedBeatmap
			RemoteProcedureCall base
		r RecommendBeatmap
			RemoteProcedureCall base
			BeatmapIdentifierNetSerializable identifier
		r ClearRecommendedBeatmap
			RemoteProcedureCall base
		d GetRecommendedBeatmap
			RemoteProcedureCall base
		s SetSelectedGameplayModifiers
			RemoteProcedureCall base
			GameplayModifiers gameplayModifiers
		n GetSelectedGameplayModifiers
			RemoteProcedureCall base
		r RecommendGameplayModifiers
			RemoteProcedureCall base
			GameplayModifiers gameplayModifiers
		n ClearRecommendedGameplayModifiers
			RemoteProcedureCall base
		d GetRecommendedGameplayModifiers
			RemoteProcedureCall base
		n LevelLoadError
			RemoteProcedureCall base
			String levelId
		n LevelLoadSuccess
			RemoteProcedureCall base
			String levelId
		n StartLevel
			RemoteProcedureCall base
			BeatmapIdentifierNetSerializable beatmapId
			GameplayModifiers gameplayModifiers
			f32 startTime
		r GetStartedLevel
			RemoteProcedureCall base
		s CancelLevelStart
			RemoteProcedureCall base
		r GetMultiplayerGameState
			RemoteProcedureCall base
		s SetMultiplayerGameState
			RemoteProcedureCall base
			vi32.MultiplayerGameState lobbyState
		d GetIsReady
			RemoteProcedureCall base
		r SetIsReady
			RemoteProcedureCall base
			b isReady
		n SetStartGameTime
			RemoteProcedureCall base
			f32 newTime
		n CancelStartGameTime
			RemoteProcedureCall base
		d GetIsInLobby
			RemoteProcedureCall base
		r SetIsInLobby
			RemoteProcedureCall base
			b isBack
		r GetCountdownEndTime
			RemoteProcedureCall base
		n SetCountdownEndTime
			RemoteProcedureCall base
			f32 newTime
		n CancelCountdown
			RemoteProcedureCall base
		n GetOwnedSongPacks
			RemoteProcedureCall base
		r SetOwnedSongPacks
			RemoteProcedureCall base
			SongPackMask songPackMask
		n RequestKickPlayer
			RemoteProcedureCall base
			String kickedPlayerId
		r GetPermissionConfiguration
			RemoteProcedureCall base
		s SetPermissionConfiguration
			RemoteProcedureCall base
			PlayersLobbyPermissionConfigurationNetSerializable playersPermissionConfiguration
		n GetIsStartButtonEnabled
			RemoteProcedureCall base
		s SetIsStartButtonEnabled
			RemoteProcedureCall base
			vi32.CannotStartGameReason reason
	u8 GameplayRpc Type
	r NodePoseSyncState
		SyncStateId id
		f32 time
		NodePoseSyncState1 state
	u8 ScoreSyncState Type
	r NodePoseSyncStateDelta
		SyncStateId baseId
		vi32 timeOffsetMs
		if(baseId.same == 0)
			NodePoseSyncState1 delta
	u8 ScoreSyncStateDelta Type
d MultiplayerSessionMessageHeader
	u8.MultiplayerSessionMessageType type
d MenuRpcHeader
	u8.MenuRpcType type
n GameplayRpcHeader
	u8.GameplayRpcType type
n ScoreSyncStateHeader
	u8.ScoreSyncStateType type
n ScoreSyncStateDeltaHeader
	u8.ScoreSyncStateDeltaType type

u8 UserMessage Type
	r AuthenticateUserRequest
		BaseMasterServerReliableResponse base
		AuthenticationToken authenticationToken
	s AuthenticateUserResponse
		BaseMasterServerReliableResponse base
		u8.AuthenticateUserResponse_Result result
	s ConnectToServerResponse 8
		BaseMasterServerReliableResponse base
		u8.ConnectToServerResponse_Result result
		if(result == GetPublicServersResponse_Result_Success)
			String userId
			String userName
			String secret
			BeatmapLevelSelectionMask selectionMask
			u8 flags
			IPEndPoint remoteEndPoint
			u8[32] random
			ByteArrayNetSerializable publicKey
			ServerCode.ServerCode code
			GameplayServerConfiguration configuration
			String managerId
	r ConnectToServerRequest
		BaseConnectToServerRequest base
		BeatmapLevelSelectionMask selectionMask
		String secret
		ServerCode.ServerCode code
		GameplayServerConfiguration configuration
	n UserMessageReceivedAcknowledge 13
		BaseMasterServerAcknowledgeMessage base
	n UserMultipartMessage
		BaseMasterServerMultipartMessage base
	n SessionKeepaliveMessage
	n GetPublicServersRequest
		BaseMasterServerReliableRequest base
		String userId
		String userName
		vi32 offset
		vi32 count
		BeatmapLevelSelectionMask selectionMask
		GameplayServerConfiguration configuration
	n GetPublicServersResponse
		BaseMasterServerReliableResponse base
		u8.GetPublicServersResponse_Result result
		if(result == GetPublicServersResponse_Result_Success)
			vu32 publicServerCount
			PublicServerInfo[8192,publicServerCount] publicServers
u8 DedicatedServerMessage Type
	z DedicatedServerMessageReceivedAcknowledge 13
	z DedicatedServerMultipartMessage 14
u8 HandshakeMessage Type
	r ClientHelloRequest
		BaseMasterServerReliableRequest base
		u8[32] random
	s HelloVerifyRequest
		BaseMasterServerReliableResponse base
		u8[32] cookie
	r ClientHelloWithCookieRequest
		BaseMasterServerReliableRequest base
		u32 certificateResponseId
		u8[32] random
		u8[32] cookie
	s ServerHelloRequest
		BaseMasterServerReliableResponse base
		u8[32] random
		ByteArrayNetSerializable publicKey
		ByteArrayNetSerializable signature
	s ServerCertificateRequest
		BaseMasterServerReliableResponse base
		vu32 certificateCount
		ByteArrayNetSerializable[10,certificateCount] certificateList
	r ClientKeyExchangeRequest 6
		BaseMasterServerReliableResponse base
		ByteArrayNetSerializable clientPublicKey
	s ChangeCipherSpecRequest
		BaseMasterServerReliableResponse base
	n HandshakeMessageReceivedAcknowledge
		BaseMasterServerAcknowledgeMessage base
	n HandshakeMultipartMessage
		BaseMasterServerMultipartMessage base

head
	#ifdef reflect
	static const char *const reflect_MessageType = "{MessageType_UserMessage=1,MessageType_DedicatedServerMessage=2,MessageType_HandshakeMessage=3192347326,}";
	#endif
	typedef uint32_t MessageType;
	#define MessageType_UserMessage 1
	#define MessageType_DedicatedServerMessage 2
	#define MessageType_HandshakeMessage 3192347326u
code
	void pkt_logMessageType(const char *name, char *buf, char *it, MessageType in) {
		fprintf(stderr, "%.*s%s=%u (%s)\n", (uint32_t)(it - buf), buf, name, in, reflect(MessageType, in));
	}
d MessageHeader
	u32.MessageType type
	vu32 protocolVersion
d SerializeHeader
	vu32 length
	u8 type
